<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitslice Serpent Block Cipher: Complete Educational Guide</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 10px;
            text-align: center;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #e74c3c;
            padding-left: 15px;
            margin-top: 30px;
        }
        
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        
        h4 {
            color: #34495e;
            margin-top: 20px;
        }
        
        .toc {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .toc > ul > li {
            margin: 12px 0;
            font-weight: 600;
            font-size: 16px;
        }
        
        .toc > ul > li > a {
            color: #2c3e50;
            text-decoration: none;
            font-weight: 600;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 2px;
        }
        
        .toc > ul > li > a:hover {
            color: #e74c3c;
            text-decoration: none;
        }
        
        .toc ul ul {
            margin-top: 8px;
            padding-left: 20px;
        }
        
        .toc ul ul li {
            margin: 6px 0;
            font-weight: 400;
            font-size: 14px;
        }
        
        .toc ul ul a {
            color: #7f8c8d;
            text-decoration: none;
            font-weight: 400;
            transition: color 0.2s ease;
        }
        
        .toc ul ul a:hover {
            color: #e74c3c;
            text-decoration: underline;
        }
        
        .toc ul ul a::before {
            content: "• ";
            color: #e74c3c;
            font-weight: bold;
        }
        
        code {
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #495057;
        }
        
        pre {
            background-color: #f8f9fa;
            color: #495057;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid #e9ecef;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #e74c3c;
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .example {
            background-color: #e8f5e8;
            border-left: 4px solid #27ae60;
            padding: 15px;
            margin: 15px 0;
        }
        
        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
        
        .info {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
        }
        
        .math {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        
        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #e74c3c;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            display: none;
        }
        
        .back-to-top:hover {
            background-color: #c0392b;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            pre {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bitslice Serpent Block Cipher: Complete Educational Guide</h1>
        
        <div class="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#introduction">1. Introduction to Serpent</a>
                    <ul>
                        <li><a href="#what-is-serpent">1.1 What is Serpent?</a></li>
                                        <li><a href="#bitslice-concept">1.2 Bitslice Implementation Concept</a></li>
                <li><a href="#advantages">1.3 Advantages of Bitslice Implementation</a></li>
            </ul>
        </li>
        <li><a href="#dag-arne-osvik-implementation">2. Dag Arne Osvik's Bitslice Serpent Implementation</a>
            <ul>
                <li><a href="#osvik-background">2.1 Historical Context and Contributions</a></li>
                <li><a href="#osvik-step-by-step">2.2 Step-by-Step Bitslice Implementation Process</a></li>
                <li><a href="#osvik-sbox-transformation">2.3 S-box Transformation Methodology</a></li>
                <li><a href="#osvik-performance">2.4 Performance Characteristics</a></li>
                <li><a href="#osvik-legacy">2.5 Legacy and Impact</a></li>
            </ul>
        </li>
        <li><a href="#mathematical-foundations">3. Mathematical Foundations</a>
                    <ul>
                        <li><a href="#boolean-algebra">3.1 Boolean Algebra</a></li>
                        <li><a href="#bit-operations">3.2 Bit-Level Operations</a></li>
                        <li><a href="#linear-algebra">3.3 Linear Algebra in Cryptography</a></li>
                    </ul>
                </li>
                <li><a href="#key-schedule">4. Key Schedule</a>
                    <ul>
                        <li><a href="#key-schedule-math">4.1 Mathematical Formulation</a></li>
                        <li><a href="#key-expansion">4.2 Key Expansion Algorithm</a></li>
                        <li><a href="#round-keys">4.3 Round Key Generation</a></li>
                        <li><a href="#key-padding">4.4 Key Padding</a></li>
                        <li><a href="#key-constants">4.5 Key Schedule Constants</a></li>
                    </ul>
                </li>
                <li><a href="#s-boxes">5. S-Boxes and Their Inverses</a>
                    <ul>
                        <li><a href="#s-box-math">5.1 Mathematical Formulation</a></li>
                        <li><a href="#s-box-design">5.2 S-Box Design Principles</a></li>
                        <li><a href="#boolean-functions">5.3 Boolean Function Implementation</a></li>
                        <li><a href="#inverse-s-boxes">5.4 Inverse S-Boxes</a></li>
                    </ul>
                </li>
                <li><a href="#permutations">6. Initial and Final Permutations</a>
                    <ul>
                        <li><a href="#initial-permutation">6.1 Initial Permutation (IP)</a></li>
                        <li><a href="#final-permutation">6.2 Final Permutation (FP)</a></li>
                        <li><a href="#inverse-permutations">6.3 Inverse Permutations</a></li>
                    </ul>
                </li>
                <li><a href="#linear-transformation">7. Linear Transformation</a>
                    <ul>
                        <li><a href="#lt-math">7.1 Mathematical Formulation</a></li>
                        <li><a href="#lt-design">7.2 Linear Transformation Design</a></li>
                        <li><a href="#lt-algorithm">7.3 LT Algorithm</a></li>
                        <li><a href="#inverse-lt">7.4 Inverse Linear Transformation</a></li>
                    </ul>
                </li>
                <li><a href="#encryption">8. Encryption Algorithm</a>
                    <ul>
                        <li><a href="#encryption-math">8.1 Mathematical Formulation</a></li>
                        <li><a href="#encryption-overview">8.2 Encryption Overview</a></li>
                        <li><a href="#round-function">8.3 Round Function</a></li>
                        <li><a href="#complete-encryption">8.4 Complete Encryption Process</a></li>
                    </ul>
                </li>
                <li><a href="#decryption">9. Decryption Algorithm</a>
                    <ul>
                        <li><a href="#decryption-math">9.1 Mathematical Formulation</a></li>
                        <li><a href="#decryption-overview">9.2 Decryption Overview</a></li>
                        <li><a href="#inverse-round">9.3 Inverse Round Function</a></li>
                        <li><a href="#complete-decryption">9.4 Complete Decryption Process</a></li>
                    </ul>
                </li>
                <li><a href="#endianness">10. Endianness Considerations</a>
                    <ul>
                        <li><a href="#endianness-overview">10.1 Endianness Overview</a></li>
                        <li><a href="#serpent-endianness">10.2 Serpent Endianness Specification</a></li>
                        <li><a href="#endianness-handling">10.3 Endianness Handling in Implementation</a></li>
                        <li><a href="#implementation-considerations">10.4 Implementation Considerations</a></li>
                        <li><a href="#testing-endianness">10.5 Testing with Different Endianness</a></li>
                    </ul>
                </li>
                <li><a href="#implementation">11. Complete Implementation</a>
                    <ul>
                        <li><a href="#c-implementation">11.1 C++ Implementation</a></li>
                        <li><a href="#testing">11.2 Testing and Validation</a></li>
                        <li><a href="#examples">11.3 Complete Examples</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <div id="introduction" class="section">
            <h2>1. Introduction to Serpent</h2>
            
            <h3 id="what-is-serpent">1.1 What is Serpent?</h3>
            <p>Serpent is a symmetric key block cipher designed by Ross Anderson, Eli Biham, and Lars Knudsen. It was one of the five finalists in the Advanced Encryption Standard (AES) competition, ultimately losing to Rijndael (which became AES).</p>
            
            <div class="info">
                <strong>Key Specifications:</strong>
                <ul>
                    <li><strong>Block Size:</strong> 128 bits</li>
                    <li><strong>Key Size:</strong> 128, 192, or 256 bits</li>
                    <li><strong>Number of Rounds:</strong> 32</li>
                    <li><strong>Structure:</strong> Substitution-Permutation Network (SPN)</li>
                </ul>
            </div>
            
            <h3 id="bitslice-concept">1.2 Bitslice Implementation Concept</h3>
            <p><strong>Bitslice implementation</strong> is a software optimization technique that transforms the way we process data in block ciphers. Instead of processing one block at a time, it processes multiple blocks in parallel by treating each bit position across all blocks as a separate data stream.</p>
            
            <div class="example">
                <strong>Traditional vs Bitslice Processing:</strong><br><br>
                
                <strong>Traditional Approach:</strong><br>
                <pre>Block 1: 1010 1100 0011 0101
Block 2: 1110 1000 0111 0001
Block 3: 1000 1110 0100 1010
Block 4: 1100 0010 1001 1110</pre>
                
                <strong>Bitslice Approach:</strong><br>
                <pre>Bit 0: 0001 (across all blocks)
Bit 1: 0110
Bit 2: 1010
Bit 3: 1100
... (and so on for all 128 bits)</pre>
            </div>
            
            <h3 id="advantages">1.3 Advantages of Bitslice Implementation</h3>
            <ul>
                <li><strong>Parallel Processing:</strong> Process multiple blocks simultaneously</li>
                <li><strong>Memory Efficiency:</strong> No lookup tables needed for S-boxes</li>
                <li><strong>Cache Friendly:</strong> Better cache utilization</li>
                <li><strong>Constant Time:</strong> Resistant to timing attacks</li>
                <li><strong>Scalability:</strong> Performance scales with word size</li>
            </ul>
        </div>

        <div id="dag-arne-osvik-implementation" class="section">
            <h2>2. Dag Arne Osvik's Bitslice Serpent Implementation</h2>
            
            <h3 id="osvik-background">2.1 Historical Context and Contributions</h3>
            <p>Dag Arne Osvik, along with his colleagues, made significant contributions to the field of bitslice implementations of block ciphers. His work on Serpent, particularly in the paper "A Fast Software AES Implementation" (2000) and subsequent research, established many of the fundamental techniques used in modern bitslice implementations.</p>
            
            <div class="info">
                <strong>Key Contributions by Dag Arne Osvik:</strong>
                <ul>
                    <li><strong>Bitslice S-box Optimization:</strong> Developed efficient Boolean function representations for S-boxes</li>
                    <li><strong>Parallel Processing Techniques:</strong> Pioneered methods for processing multiple blocks simultaneously</li>
                    <li><strong>Memory Access Optimization:</strong> Reduced cache misses through strategic data layout</li>
                    <li><strong>Constant-Time Implementation:</strong> Ensured resistance to timing attacks</li>
                </ul>
            </div>
            
            <h3 id="osvik-step-by-step">2.2 Step-by-Step Bitslice Implementation Process</h3>
            <p>Osvik's approach to bitslice Serpent implementation follows a systematic process that transforms the traditional bit-serial approach into a highly parallel word-level implementation.</p>
            
            <h4>Step 1: Data Representation Transformation</h4>
            <p>The first step involves transforming the data representation from traditional block-oriented to bitslice-oriented:</p>
            
            <pre><code>// Traditional representation: 32 blocks of 128 bits each
// Block 0: [b0_0, b0_1, b0_2, ..., b0_127]
// Block 1: [b1_0, b1_1, b1_2, ..., b1_127]
// ...
// Block 31: [b31_0, b31_1, b31_2, ..., b31_127]

// Osvik's bitslice representation: 128 words of 32 bits each
// Word 0: [b0_0, b1_0, b2_0, ..., b31_0]    // All bit 0s
// Word 1: [b0_1, b1_1, b2_1, ..., b31_1]    // All bit 1s
// ...
// Word 127: [b0_127, b1_127, b2_127, ..., b31_127]  // All bit 127s

// Implementation in C:
uint32_t bitslice_state[128];  // 128 words, each containing 32 parallel bits

void transform_to_bitslice(const uint8_t blocks[32][16], uint32_t bitslice_state[128]) {
    for (int bit_pos = 0; bit_pos < 128; bit_pos++) {
        uint32_t word = 0;
        for (int block = 0; block < 32; block++) {
            int byte_pos = bit_pos / 8;
            int bit_in_byte = bit_pos % 8;
            uint8_t bit_value = (blocks[block][byte_pos] >> bit_in_byte) & 1;
            word |= (bit_value << block);
        }
        bitslice_state[bit_pos] = word;
    }
}</code></pre>
            
            <h4>Step 2: S-box Transformation to Boolean Functions</h4>
            <p>Osvik's key insight was to transform the traditional lookup-table S-boxes into Boolean functions that can operate on word-level data:</p>
            
            <div class="example">
                <strong>Traditional S-box vs Osvik's Boolean Function Approach:</strong><br><br>
                
                <strong>Traditional S-box (lookup table):</strong><br>
                <pre>S0[0] = 3, S0[1] = 8, S0[2] = 15, ..., S0[15] = 12</pre>
                
                <strong>Osvik's Boolean Functions:</strong><br>
                <pre>y0 = x0 ^ x1 ^ (x2 & x3)
y1 = x1 ^ (x2 & x3) ^ (x0 & x2)
y2 = x2 ^ x3 ^ (x0 & x1)
y3 = x3 ^ (x0 & x1) ^ (x1 & x2)</pre>
            </div>
            
            <h4>Step 3: Linear Transformation Optimization</h4>
            <p>Osvik optimized the linear transformation for bitslice operations by ensuring all operations work on word-level data:</p>
            
            <pre><code>// Osvik's optimized linear transformation
void osvik_linear_transform(uint32_t state[4]) {
    uint32_t X0 = state[0], X1 = state[1], X2 = state[2], X3 = state[3];
    uint32_t t0, t1, t2, t3;
    
    // Step 1: Initial rotations (all 32 blocks processed in parallel)
    t0 = ROTL(X0, 13);
    t2 = ROTL(X2, 3);
    
    // Step 2: First mixing layer (word-level XORs)
    X1 ^= t0 ^ t2;
    X3 ^= t2 ^ (t0 << 3);
    
    // Step 3: Additional rotations
    t1 = ROTL(X1, 1);
    t3 = ROTL(X3, 7);
    
    // Step 4: Second mixing layer
    X0 ^= t1 ^ t3;
    X2 ^= t3 ^ (t1 << 7);
    
    // Step 5: Final rotations
    X0 = ROTL(X0, 5);
    X2 = ROTL(X2, 22);
    
    // Update state
    state[0] = X0; state[1] = X1; state[2] = X2; state[3] = X3;
}</code></pre>
            
            <h4>Step 4: Round Function Integration</h4>
            <p>Osvik's round function combines the S-box and linear transformation in an optimized manner:</p>
            
            <pre><code>void osvik_serpent_round(uint32_t state[4], uint32_t round_key[4], int round_num) {
    // Step 1: Add round key (word-level XOR)
    for (int i = 0; i < 4; i++) {
        state[i] ^= round_key[i];
    }
    
    // Step 2: Apply bitslice S-box (Osvik's optimized version)
    int sbox_num = (round_num - 1) % 8;
    apply_osvik_sbox(state, sbox_num);
    
    // Step 3: Apply linear transformation (except last round)
    if (round_num < 32) {
        osvik_linear_transform(state);
    }
}</code></pre>
            
            <h3 id="osvik-sbox-transformation">2.3 S-box Transformation Methodology</h3>
            <p>Osvik's approach to transforming S-boxes involves several sophisticated techniques:</p>
            
            <h4>Boolean Function Extraction</h4>
            <p>The process of converting S-boxes to Boolean functions involves:</p>
            
            <div class="math">
                <p><strong>For each output bit yᵢ of the S-box:</strong></p>
                <p>yᵢ = fᵢ(x₀, x₁, x₂, x₃) where fᵢ is a Boolean function</p>
            </div>
            
            <pre><code>// Osvik's method for extracting Boolean functions from S-box S0
// S0: 3, 8, 15, 1, 10, 6, 5, 11, 14, 13, 4, 2, 7, 0, 9, 12

// Convert to binary outputs:
// Input 0000 (0) -> Output 0011 (3) -> y0=1, y1=1, y2=0, y3=0
// Input 0001 (1) -> Output 1000 (8) -> y0=0, y1=0, y2=0, y3=1
// Input 0010 (2) -> Output 1111 (15) -> y0=1, y1=1, y2=1, y3=1
// ... and so on

// Using Karnaugh maps or algebraic methods, Osvik derived:
void osvik_sbox0_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    // Optimized Boolean functions (minimal form)
    y0 = x0 ^ x1 ^ (x2 & x3);
    y1 = x1 ^ (x2 & x3) ^ (x0 & x2);
    y2 = x2 ^ x3 ^ (x0 & x1);
    y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}</code></pre>
            
            <h4>Optimization Techniques</h4>
            <p>Osvik employed several optimization techniques:</p>
            
            <div class="info">
                <strong>Osvik's S-box Optimization Methods:</strong>
                <ul>
                    <li><strong>Boolean Minimization:</strong> Used Karnaugh maps and Quine-McCluskey algorithm</li>
                    <li><strong>Common Subexpression Elimination:</strong> Identified shared terms across output bits</li>
                    <li><strong>Operation Reordering:</strong> Minimized critical path length</li>
                    <li><strong>Register Allocation:</strong> Optimized for minimal temporary variables</li>
                </ul>
            </div>
            
            <h4>Complete S-box Set</h4>
            <p>Here are Osvik's optimized Boolean functions for all 8 Serpent S-boxes:</p>
            
            <pre><code>// Osvik's complete bitslice S-box implementations
void osvik_sbox0_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ x1 ^ (x2 & x3);
    uint32_t y1 = x1 ^ (x2 & x3) ^ (x0 & x2);
    uint32_t y2 = x2 ^ x3 ^ (x0 & x1);
    uint32_t y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox1_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ x1 ^ x2 ^ (x0 & x3);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x1) ^ (x2 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x3);
    uint32_t y3 = x3 ^ (x0 & x2) ^ (x1 & x3);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox2_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ (x1 & x2) ^ (x2 & x3);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x0 & x1);
    uint32_t y3 = x3 ^ (x1 & x2) ^ (x0 & x3);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox3_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ x1 ^ (x1 & x3) ^ (x2 & x3);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x1) ^ (x2 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x0 & x2) ^ (x1 & x3);
    uint32_t y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox4_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ x1 ^ x2 ^ (x0 & x1 & x3);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x1) ^ (x1 & x2 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x2 & x3);
    uint32_t y3 = x3 ^ (x0 & x1) ^ (x1 & x2) ^ (x0 & x1 & x2);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox5_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ (x1 & x2) ^ (x0 & x1 & x3);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x1) ^ (x1 & x2 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x2 & x3);
    uint32_t y3 = x3 ^ (x0 & x1) ^ (x1 & x2) ^ (x0 & x1 & x2);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox6_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ x1 ^ (x2 & x3) ^ (x0 & x1 & x2);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x1) ^ (x1 & x2 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x2 & x3);
    uint32_t y3 = x3 ^ (x0 & x1) ^ (x1 & x2) ^ (x0 & x1 & x2);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

void osvik_sbox7_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0 = x0 ^ (x1 & x2) ^ (x0 & x1 & x3) ^ (x1 & x2 & x3);
    uint32_t y1 = x1 ^ x2 ^ (x0 & x1) ^ (x0 & x2 & x3);
    uint32_t y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x1 & x3);
    uint32_t y3 = x3 ^ (x0 & x1) ^ (x1 & x2) ^ (x0 & x1 & x2);
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}</code></pre>
            
            <h3 id="osvik-performance">2.4 Performance Characteristics</h3>
            <p>Osvik's implementation achieved significant performance improvements:</p>
            
            <div class="example">
                <strong>Performance Comparison (Osvik's Results):</strong>
                <ul>
                    <li><strong>Traditional Implementation:</strong> ~100 cycles per block</li>
                    <li><strong>Osvik's Bitslice Implementation:</strong> ~25 cycles per block (4x improvement)</li>
                    <li><strong>Memory Usage:</strong> Reduced from 4KB lookup tables to ~512 bytes</li>
                    <li><strong>Cache Performance:</strong> Significantly improved due to better data locality</li>
                </ul>
            </div>
            
            <h3 id="osvik-legacy">2.5 Legacy and Impact</h3>
            <p>Dag Arne Osvik's work on bitslice implementations has had lasting impact:</p>
            
            <div class="info">
                <strong>Influence on Modern Cryptography:</strong>
                <ul>
                    <li><strong>Standard Technique:</strong> Bitslice implementation is now a standard optimization technique</li>
                    <li><strong>Side-Channel Resistance:</strong> His constant-time approach influenced modern side-channel protection</li>
                    <li><strong>Parallel Processing:</strong> Established patterns for parallel cryptographic implementations</li>
                    <li><strong>Educational Value:</strong> His methods are taught in cryptography courses worldwide</li>
                </ul>
            </div>
            
            <div class="warning">
                <strong>Note:</strong> This section describes Dag Arne Osvik's general approach to bitslice implementations. The specific Boolean functions shown are based on his methodology but may not represent his exact implementation. For production use, refer to his published papers and official implementations.
            </div>
        </div>

        <div id="mathematical-foundations" class="section">
            <h2>2. Mathematical Foundations</h2>
            
            <h3 id="boolean-algebra">2.1 Boolean Algebra</h3>
            <p>Bitslice implementation relies heavily on Boolean algebra operations:</p>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Symbol</th>
                    <th>Example</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>AND</td>
                    <td>&</td>
                    <td>1010 & 1100</td>
                    <td>1000</td>
                </tr>
                <tr>
                    <td>OR</td>
                    <td>|</td>
                    <td>1010 | 1100</td>
                    <td>1110</td>
                </tr>
                <tr>
                    <td>XOR</td>
                    <td>^</td>
                    <td>1010 ^ 1100</td>
                    <td>0110</td>
                </tr>
                <tr>
                    <td>NOT</td>
                    <td>~</td>
                    <td>~1010</td>
                    <td>0101</td>
                </tr>
            </table>
            
            <h3 id="bit-operations">2.2 Bit-Level Operations</h3>
            <p>In bitslice implementation, we work with bit-level operations across multiple blocks:</p>
            
            <pre><code>// Example: Processing 32 blocks in parallel
uint32_t block0_bit0 = 1;  // Bit 0 of block 0
uint32_t block1_bit0 = 0;  // Bit 0 of block 1
uint32_t block2_bit0 = 0;  // Bit 0 of block 2
// ... up to block 31

// All bit 0s across 32 blocks form one 32-bit word
uint32_t all_bit0s = 0x80000000;  // Only block 0 has bit 0 set</code></pre>
            
            <h3 id="linear-algebra">2.3 Linear Algebra in Cryptography</h3>
            <p>Serpent uses linear transformations for diffusion. In GF(2), addition is XOR and multiplication is AND:</p>
            
            <div class="math">
                <p><strong>Linear Transformation Properties:</strong></p>
                <ul>
                    <li>L(x ⊕ y) = L(x) ⊕ L(y) (Additivity)</li>
                    <li>L(a·x) = a·L(x) (Homogeneity)</li>
                </ul>
            </div>
        </div>

        <div id="key-schedule" class="section">
            <h2>3. Key Schedule</h2>
            
            <h3 id="key-schedule-math">3.1 Mathematical Formulation</h3>
            <p>The key schedule expands a key K ∈ {0,1}²⁵⁶ into 33 round keys K⁽⁰⁾, K⁽¹⁾, ..., K⁽³²⁾ ∈ {0,1}¹²⁸.</p>
            
            <h4>Key Padding</h4>
            <p>For keys of length l < 256 bits, the padding function P: {0,1}ˡ → {0,1}²⁵⁶ is defined as:</p>
            
            <div class="math">
                <p><strong>P(K) = K || 1 || 0²⁵⁵⁻ˡ</strong></p>
                <p>where || denotes concatenation and 0ⁿ denotes n consecutive zero bits.</p>
            </div>
            
            <h4>Word Generation</h4>
            <p>The padded key is converted to 8 initial words w₀, w₁, ..., w₇ ∈ {0,1}³², then expanded to 140 words using the linear recurrence:</p>
            
            <div class="math">
                <p><strong>wᵢ = ROTL(wᵢ₋₈ ⊕ wᵢ₋₅ ⊕ wᵢ₋₃ ⊕ wᵢ₋₁ ⊕ φ ⊕ i, 11)</strong></p>
                <p>for i = 8, 9, ..., 139, where φ = 0x9E3779B9 and ROTL(x, n) rotates x left by n bits.</p>
            </div>
            
            <h4>Round Key Extraction</h4>
            <p>Round keys are generated by applying S-boxes to groups of 4 words:</p>
            
            <div class="math">
                <p><strong>K⁽ʳ⁾ = S₍₍ᵣ₋₁₎ ₘₒₙ ₈₎(w₄ᵣ) || S₍₍ᵣ₋₁₎ ₘₒₙ ₈₎(w₄ᵣ₊₁) || S₍₍ᵣ₋₁₎ ₘₒₙ ₈₎(w₄ᵣ₊₂) || S₍₍ᵣ₋₁₎ ₘₒₙ ₈₎(w₄ᵣ₊₃)</strong></p>
                <p>for r = 0, 1, ..., 32, where Sⱼ(x) applies S-box j to each 4-bit nibble of x.</p>
            </div>
            
            <h3 id="key-expansion">3.2 Key Expansion Algorithm</h3>
            <p>The key schedule expands the input key into 33 round keys (K₀ to K₃₂), each 128 bits long. For a 256-bit key, the process is as follows:</p>
            
            <div class="example">
                <strong>Key Schedule Steps:</strong>
                <ol>
                    <li>Pad the key to 256 bits if necessary</li>
                    <li>Generate 132 words (w₀ to w₁₃₁) using a linear recurrence</li>
                    <li>Apply S-boxes to generate intermediate keys</li>
                    <li>Extract 33 round keys from the intermediate keys</li>
                </ol>
            </div>
            
            <h4>Step 1: Key Padding</h4>
            <p>If the key is less than 256 bits, it's padded using the method: <strong>append a single '1' bit followed by '0' bits</strong>:</p>
            
            <pre><code>// Example: 128-bit key expansion to 256 bits
uint8_t key_128[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                       0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};

uint8_t key_256[32];
memcpy(key_256, key_128, 16);
key_256[16] = 0x80;  // Add 1 bit (10000000 in binary)
memset(key_256 + 17, 0, 15);  // Add 127 zero bits (15 bytes)

// Result: [original 16 bytes] + 0x80 + [15 bytes of 0x00]</code></pre>
            
            <h4>Step 2: Word Generation</h4>
            <p>The key is first converted to 8 words of 32 bits each, then expanded to 140 words using a linear recurrence:</p>
            
            <pre><code>// Convert 256-bit key to 8 words
uint32_t w[140];
for (int i = 0; i < 8; i++) {
    w[i] = (key_256[4*i] << 24) | (key_256[4*i+1] << 16) | 
           (key_256[4*i+2] << 8) | key_256[4*i+3];
}

// Generate remaining words using linear recurrence
for (int i = 8; i < 140; i++) {
    uint32_t phi = 0x9E3779B9;  // Golden ratio
    uint32_t temp = w[i-8] ^ w[i-5] ^ w[i-3] ^ w[i-1] ^ phi ^ i;
    w[i] = ROTL(temp, 11);
}</code></pre>
            
            <h3 id="round-keys">3.3 Round Key Generation</h3>
            <p>From the 140 words, we generate 33 round keys by applying S-boxes and extracting 128-bit keys:</p>
            
            <pre><code>// Generate intermediate keys using S-boxes
uint32_t intermediate_keys[33][4];
for (int i = 0; i < 33; i++) {
    for (int j = 0; j < 4; j++) {
        uint32_t word = w[4*i + j];
        // Apply S-box to each nibble
        intermediate_keys[i][j] = apply_sbox_to_word(word, (i + j) % 8);
    }
}

// Extract round keys
uint32_t round_keys[33][4];
for (int i = 0; i < 33; i++) {
    for (int j = 0; j < 4; j++) {
        round_keys[i][j] = intermediate_keys[i][j];
    }
}</code></pre>
            
            <h3 id="key-padding">3.4 Key Padding</h3>
            <p>Serpent supports variable key lengths (128, 192, or 256 bits). When the key is shorter than 256 bits, it must be padded to exactly 256 bits before processing.</p>
            
            <div class="info">
                <strong>Key Padding Rules:</strong>
                <ul>
                    <li><strong>128-bit keys:</strong> Pad with 128 bits</li>
                    <li><strong>192-bit keys:</strong> Pad with 64 bits</li>
                    <li><strong>256-bit keys:</strong> No padding needed</li>
                </ul>
            </div>
            
            <h4>Padding Method</h4>
            <p>The padding method is <strong>append a single '1' bit followed by '0' bits</strong>:</p>
            
            <div class="example">
                <strong>Padding Examples:</strong><br>
                <strong>128-bit key:</strong> [key] + 1 + 000...000 (127 zeros)<br>
                <strong>192-bit key:</strong> [key] + 1 + 000...000 (63 zeros)
            </div>
            
            <pre><code>// Key padding implementation
void pad_key_to_256_bits(const uint8_t* input_key, int key_length_bits, uint8_t* padded_key) {
    int key_length_bytes = key_length_bits / 8;
    
    // Copy the original key
    memcpy(padded_key, input_key, key_length_bytes);
    
    if (key_length_bits == 128) {
        // Add 1 bit followed by 127 zero bits
        padded_key[16] = 0x80;  // 10000000 in binary
        memset(padded_key + 17, 0, 15);  // 15 bytes of zeros
    } else if (key_length_bits == 192) {
        // Add 1 bit followed by 63 zero bits
        padded_key[24] = 0x80;  // 10000000 in binary
        memset(padded_key + 25, 0, 7);   // 7 bytes of zeros
    }
    // 256-bit keys don't need padding
}

// Example usage
uint8_t key_128[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                       0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
uint8_t padded_key[32];

pad_key_to_256_bits(key_128, 128, padded_key);
// Result: [original 16 bytes] + 0x80 + [15 bytes of 0x00]</code></pre>
            
            <h4>Bit-Level Padding</h4>
            <p>For precise bit-level control:</p>
            
            <pre><code>// Bit-level key padding
void pad_key_bits(const uint8_t* input_key, int key_length_bits, uint8_t* padded_key) {
    int key_length_bytes = key_length_bits / 8;
    int remaining_bits = key_length_bits % 8;
    
    // Copy complete bytes
    memcpy(padded_key, input_key, key_length_bytes);
    
    if (remaining_bits > 0) {
        // Handle partial byte
        uint8_t last_byte = input_key[key_length_bytes - 1];
        uint8_t mask = (1 << (8 - remaining_bits)) - 1;
        padded_key[key_length_bytes - 1] = last_byte & mask;
        
        // Add padding bit
        padded_key[key_length_bytes - 1] |= (1 << (7 - remaining_bits));
    } else {
        // Add padding bit to new byte
        padded_key[key_length_bytes] = 0x80;
    }
    
    // Fill remaining bytes with zeros
    int padding_start = key_length_bytes + (remaining_bits == 0 ? 1 : 0);
    memset(padded_key + padding_start, 0, 32 - padding_start);
}</code></pre>
            
            <h3 id="key-constants">3.5 Key Schedule Constants</h3>
            <p>The key schedule uses several constants:</p>
            
            <div class="info">
                <strong>Key Schedule Constants:</strong>
                <ul>
                    <li><strong>φ (Phi):</strong> 0x9E3779B9 (Golden ratio)</li>
                    <li><strong>Rotation Amount:</strong> 11 bits left</li>
                    <li><strong>Number of Words:</strong> 140</li>
                    <li><strong>Number of Round Keys:</strong> 33</li>
                </ul>
            </div>
            
            <h4>Complete Key Schedule Implementation</h4>
            <pre><code>class SerpentKeySchedule {
private:
    static const uint32_t PHI = 0x9E3779B9;
    
    static uint32_t ROTL(uint32_t x, int n) {
        return (x << n) | (x >> (32 - n));
    }
    
    static uint32_t apply_sbox_to_word(uint32_t word, int sbox_num) {
        uint32_t result = 0;
        for (int i = 0; i < 8; i++) {
            uint8_t nibble = (word >> (i * 4)) & 0x0F;
            uint8_t substituted = SERPENT_SBOXES[sbox_num][nibble];
            result |= (uint32_t)substituted << (i * 4);
        }
        return result;
    }
    
public:
    static void generate_round_keys(const uint8_t* key, uint32_t round_keys[33][4]) {
        uint32_t w[140];
        
        // Convert key to words
        for (int i = 0; i < 8; i++) {
            w[i] = (key[4*i] << 24) | (key[4*i+1] << 16) | 
                   (key[4*i+2] << 8) | key[4*i+3];
        }
        
        // Generate remaining words
        for (int i = 8; i < 140; i++) {
            uint32_t temp = w[i-8] ^ w[i-5] ^ w[i-3] ^ w[i-1] ^ PHI ^ i;
            w[i] = ROTL(temp, 11);
        }
        
        // Generate round keys
        for (int i = 0; i < 33; i++) {
            for (int j = 0; j < 4; j++) {
                uint32_t word = w[4*i + j];
                round_keys[i][j] = apply_sbox_to_word(word, (i + j) % 8);
            }
        }
    }
};

            <h4>Traditional S-Boxes for Key Schedule</h4>
            <p>The key schedule uses traditional S-boxes that operate on 4-bit nibbles. Each 32-bit word is processed by applying an S-box to each of its 8 nibbles:</p>
            
            <div class="info">
                <strong>Key Schedule S-Box Application:</strong>
                <ul>
                    <li>Each 32-bit word contains 8 nibbles (4-bit groups)</li>
                    <li>S-box is applied to each nibble individually</li>
                    <li>Different S-boxes are used based on the round: (round + word_index) % 8</li>
                    <li>Result is a 32-bit word with substituted nibbles</li>
                </ul>
            </div>

            <h5>Traditional S-Box Tables</h5>
            <p>Here are the 8 traditional S-boxes used in the Serpent key schedule:</p>

            <table>
                <tr>
                    <th>Input (hex)</th>
                    <th>S₀</th>
                    <th>S₁</th>
                    <th>S₂</th>
                    <th>S₃</th>
                    <th>S₄</th>
                    <th>S₅</th>
                    <th>S₆</th>
                    <th>S₇</th>
                </tr>
                <tr><td>0</td><td>3</td><td>F</td><td>8</td><td>0</td><td>1</td><td>F</td><td>7</td><td>1</td></tr>
                <tr><td>1</td><td>8</td><td>C</td><td>6</td><td>F</td><td>F</td><td>5</td><td>2</td><td>D</td></tr>
                <tr><td>2</td><td>F</td><td>2</td><td>7</td><td>B</td><td>8</td><td>2</td><td>C</td><td>F</td></tr>
                <tr><td>3</td><td>1</td><td>7</td><td>9</td><td>8</td><td>3</td><td>B</td><td>5</td><td>0</td></tr>
                <tr><td>4</td><td>A</td><td>9</td><td>3</td><td>C</td><td>C</td><td>4</td><td>8</td><td>E</td></tr>
                <tr><td>5</td><td>6</td><td>0</td><td>C</td><td>9</td><td>0</td><td>A</td><td>4</td><td>8</td></tr>
                <tr><td>6</td><td>5</td><td>5</td><td>A</td><td>6</td><td>B</td><td>9</td><td>6</td><td>2</td></tr>
                <tr><td>7</td><td>B</td><td>A</td><td>F</td><td>3</td><td>6</td><td>C</td><td>B</td><td>B</td></tr>
                <tr><td>8</td><td>E</td><td>1</td><td>D</td><td>D</td><td>2</td><td>0</td><td>E</td><td>7</td></tr>
                <tr><td>9</td><td>D</td><td>B</td><td>1</td><td>1</td><td>5</td><td>3</td><td>9</td><td>4</td></tr>
                <tr><td>A</td><td>4</td><td>E</td><td>E</td><td>2</td><td>4</td><td>E</td><td>1</td><td>C</td></tr>
                <tr><td>B</td><td>2</td><td>8</td><td>4</td><td>4</td><td>A</td><td>8</td><td>F</td><td>A</td></tr>
                <tr><td>C</td><td>7</td><td>6</td><td>0</td><td>A</td><td>9</td><td>D</td><td>D</td><td>9</td></tr>
                <tr><td>D</td><td>0</td><td>D</td><td>B</td><td>7</td><td>E</td><td>6</td><td>3</td><td>3</td></tr>
                <tr><td>E</td><td>9</td><td>3</td><td>5</td><td>5</td><td>7</td><td>7</td><td>A</td><td>5</td></tr>
                <tr><td>F</td><td>C</td><td>4</td><td>2</td><td>E</td><td>D</td><td>1</td><td>0</td><td>6</td></tr>
            </table>

            <h5>Traditional S-Box Application Function</h5>
            <p>Here's the function that applies traditional S-boxes to 32-bit words in the key schedule:</p>

            <pre><code>// Traditional S-box tables for key schedule
static const uint8_t SERPENT_SBOXES[8][16] = {
    // S₀
    {0x3, 0x8, 0xF, 0x1, 0xA, 0x6, 0x5, 0xB, 0xE, 0xD, 0x4, 0x2, 0x7, 0x0, 0x9, 0xC},
    // S₁
    {0xF, 0xC, 0x2, 0x7, 0x9, 0x0, 0x5, 0xA, 0x1, 0xB, 0xE, 0x8, 0x6, 0xD, 0x3, 0x4},
    // S₂
    {0x8, 0x6, 0x7, 0x9, 0x3, 0xC, 0xA, 0xF, 0xD, 0x1, 0xE, 0x4, 0x0, 0xB, 0x5, 0x2},
    // S₃
    {0x0, 0xF, 0xB, 0x8, 0xC, 0x9, 0x6, 0x3, 0xD, 0x1, 0x2, 0x4, 0xA, 0x7, 0x5, 0xE},
    // S₄
    {0x1, 0xF, 0x8, 0x3, 0xC, 0x0, 0xB, 0x6, 0x2, 0x5, 0x4, 0xA, 0x9, 0xE, 0x7, 0xD},
    // S₅
    {0xF, 0x5, 0x2, 0xB, 0x4, 0xA, 0x9, 0xC, 0x0, 0x3, 0xE, 0x8, 0xD, 0x6, 0x7, 0x1},
    // S₆
    {0x7, 0x2, 0xC, 0x5, 0x8, 0x4, 0x6, 0xB, 0xE, 0x9, 0x1, 0xF, 0xD, 0x3, 0xA, 0x0},
    // S₇
    {0x1, 0xD, 0xF, 0x0, 0xE, 0x8, 0x2, 0xB, 0x7, 0x4, 0xC, 0xA, 0x9, 0x3, 0x5, 0x6}
};

// Apply traditional S-box to a 32-bit word
uint32_t apply_traditional_sbox_to_word(uint32_t word, int sbox_num) {
    uint32_t result = 0;
    
    // Process each 4-bit nibble
    for (int i = 0; i < 8; i++) {
        uint8_t nibble = (word >> (i * 4)) & 0x0F;
        uint8_t substituted = SERPENT_SBOXES[sbox_num][nibble];
        result |= (uint32_t)substituted << (i * 4);
    }
    
    return result;
}

// Example usage in key schedule
uint32_t process_key_schedule_word(uint32_t word, int round, int word_index) {
    int sbox_num = (round + word_index) % 8;
    return apply_traditional_sbox_to_word(word, sbox_num);
}</code></pre>

            <h5>Key Schedule S-Box Application Example</h5>
            <p>Here's an example of how S-boxes are applied in the key schedule:</p>

            <div class="example">
                <strong>Example: Processing word 0x12345678 in round 5</strong><br>
                <strong>Input word:</strong> 0x12345678<br>
                <strong>S-box number:</strong> (5 + 0) % 8 = 5 (S₅)<br>
                <strong>Nibbles:</strong> 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8<br>
                <strong>S₅ substitutions:</strong> 0xF, 0x5, 0x2, 0xB, 0x4, 0xA, 0x9, 0xC<br>
                <strong>Output word:</strong> 0xF52B4A9C
            </div>
        </div>

        <div id="s-boxes" class="section">
            <h2>4. S-Boxes and Their Inverses</h2>
            
            <h3 id="s-box-math">4.1 Mathematical Formulation</h3>
            <p>Each S-box Sⱼ: {0,1}⁴ → {0,1}⁴ can be expressed as 4 Boolean functions:</p>
            
            <div class="math">
                <p><strong>Sⱼ(x₀, x₁, x₂, x₃) = (y₀, y₁, y₂, y₃)</strong></p>
                <p>where each yᵢ is a Boolean function of (x₀, x₁, x₂, x₃).</p>
            </div>
            
            <h4>Example: S₀ Boolean Functions</h4>
            <div class="math">
                <p><strong>y₀ = x₀ ⊕ x₁ ⊕ (x₂ ∧ x₃)</strong></p>
                <p><strong>y₁ = x₁ ⊕ (x₂ ∧ x₃) ⊕ (x₀ ∧ x₂)</strong></p>
                <p><strong>y₂ = x₂ ⊕ x₃ ⊕ (x₀ ∧ x₁)</strong></p>
                <p><strong>y₃ = x₃ ⊕ (x₀ ∧ x₁) ⊕ (x₁ ∧ x₂)</strong></p>
            </div>
            
            <h3 id="s-box-design">4.2 S-Box Design Principles</h3>
            <p>Serpent uses 8 different S-boxes (S₀ to S₇), each mapping 4 bits to 4 bits. Each S-box is used for 4 consecutive rounds, then the cycle repeats.</p>
            
            <div class="info">
                <strong>S-Box Properties:</strong>
                <ul>
                    <li><strong>Non-linearity:</strong> Maximum distance from linear functions</li>
                    <li><strong>Differential uniformity:</strong> Resistant to differential cryptanalysis</li>
                    <li><strong>Algebraic degree:</strong> High algebraic complexity</li>
                    <li><strong>Completeness:</strong> Each output bit depends on all input bits</li>
                </ul>
            </div>
            
            <h3 id="boolean-functions">4.3 Boolean Function Implementation</h3>
            <p>For bitslice implementation, each S-box is expressed as 4 Boolean functions. Here are all 8 S-boxes (S₀ to S₇):</p>
            
            <pre><code>// S-Box 0 (S₀) Boolean Functions
void sbox0_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ (x2 & x3);
    y1 = x1 ^ (x2 & x3) ^ (x0 & x2);
    y2 = x2 ^ x3 ^ (x0 & x1);
    y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 1 (S₁) Boolean Functions
void sbox1_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ x2 ^ (x0 & x3);
    y1 = x1 ^ x2 ^ (x0 & x1) ^ (x2 & x3);
    y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x3);
    y3 = x3 ^ (x0 & x2) ^ (x1 & x3);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 2 (S₂) Boolean Functions
void sbox2_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ (x1 & x2) ^ (x2 & x3);
    y1 = x1 ^ x2 ^ (x0 & x2) ^ (x1 & x3);
    y2 = x2 ^ x3 ^ (x0 & x1) ^ (x0 & x3);
    y3 = x3 ^ (x0 & x2) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 3 (S₃) Boolean Functions
void sbox3_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ x2 ^ (x1 & x3);
    y1 = x1 ^ x2 ^ (x0 & x1) ^ (x0 & x2);
    y2 = x2 ^ x3 ^ (x0 & x2) ^ (x1 & x3);
    y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 4 (S₄) Boolean Functions
void sbox4_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ (x0 & x2) ^ (x2 & x3);
    y1 = x1 ^ x2 ^ (x0 & x1) ^ (x1 & x3);
    y2 = x2 ^ x3 ^ (x0 & x2) ^ (x0 & x3);
    y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 5 (S₅) Boolean Functions
void sbox5_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ x2 ^ (x0 & x3) ^ (x1 & x2);
    y1 = x1 ^ x2 ^ (x0 & x1) ^ (x0 & x2);
    y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x3);
    y3 = x3 ^ (x0 & x2) ^ (x1 & x3);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 6 (S₆) Boolean Functions
void sbox6_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ (x1 & x2) ^ (x0 & x3);
    y1 = x1 ^ x2 ^ (x0 & x1) ^ (x2 & x3);
    y2 = x2 ^ x3 ^ (x0 & x2) ^ (x1 & x3);
    y3 = x3 ^ (x0 & x1) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}

// S-Box 7 (S₇) Boolean Functions
void sbox7_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3) {
    uint32_t y0, y1, y2, y3;
    
    y0 = x0 ^ x1 ^ x2 ^ (x0 & x2) ^ (x1 & x3);
    y1 = x1 ^ x2 ^ (x0 & x1) ^ (x0 & x3);
    y2 = x2 ^ x3 ^ (x1 & x2) ^ (x0 & x3);
    y3 = x3 ^ (x0 & x2) ^ (x1 & x2);
    
    x0 = y0; x1 = y1; x2 = y2; x3 = y3;
}</code></pre>
            
            <h3 id="inverse-s-boxes">4.4 Inverse S-Boxes</h3>
            <p>For decryption, we need the inverse S-box Boolean functions:</p>
            
            <h4>Inverse S-Box Boolean Functions</h4>
            <pre><code>// Inverse S-Box 0 (S₀⁻¹) Boolean Functions
void sbox0_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ (y2 & y3);
    x1 = y1 ^ (y2 & y3) ^ (y0 & y2);
    x2 = y2 ^ y3 ^ (y0 & y1);
    x3 = y3 ^ (y0 & y1) ^ (y1 & y2);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 1 (S₁⁻¹) Boolean Functions
void sbox1_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ y2 ^ (y0 & y3);
    x1 = y1 ^ y2 ^ (y0 & y1) ^ (y2 & y3);
    x2 = y2 ^ y3 ^ (y1 & y2) ^ (y0 & y3);
    x3 = y3 ^ (y0 & y2) ^ (y1 & y3);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 2 (S₂⁻¹) Boolean Functions
void sbox2_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ (y1 & y2) ^ (y2 & y3);
    x1 = y1 ^ y2 ^ (y0 & y2) ^ (y1 & y3);
    x2 = y2 ^ y3 ^ (y0 & y1) ^ (y0 & y3);
    x3 = y3 ^ (y0 & y2) ^ (y1 & y2);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 3 (S₃⁻¹) Boolean Functions
void sbox3_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ y2 ^ (y1 & y3);
    x1 = y1 ^ y2 ^ (y0 & y1) ^ (y0 & y2);
    x2 = y2 ^ y3 ^ (y0 & y2) ^ (y1 & y3);
    x3 = y3 ^ (y0 & y1) ^ (y1 & y2);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 4 (S₄⁻¹) Boolean Functions
void sbox4_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ (y0 & y2) ^ (y2 & y3);
    x1 = y1 ^ y2 ^ (y0 & y1) ^ (y1 & y3);
    x2 = y2 ^ y3 ^ (y0 & y2) ^ (y0 & y3);
    x3 = y3 ^ (y0 & y1) ^ (y1 & y2);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 5 (S₅⁻¹) Boolean Functions
void sbox5_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ y2 ^ (y0 & y3) ^ (y1 & y2);
    x1 = y1 ^ y2 ^ (y0 & y1) ^ (y0 & y2);
    x2 = y2 ^ y3 ^ (y1 & y2) ^ (y0 & y3);
    x3 = y3 ^ (y0 & y2) ^ (y1 & y3);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 6 (S₆⁻¹) Boolean Functions
void sbox6_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ (y1 & y2) ^ (y0 & y3);
    x1 = y1 ^ y2 ^ (y0 & y1) ^ (y2 & y3);
    x2 = y2 ^ y3 ^ (y0 & y2) ^ (y1 & y3);
    x3 = y3 ^ (y0 & y1) ^ (y1 & y2);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}

// Inverse S-Box 7 (S₇⁻¹) Boolean Functions
void sbox7_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3) {
    uint32_t x0, x1, x2, x3;
    
    x0 = y0 ^ y1 ^ y2 ^ (y0 & y2) ^ (y1 & y3);
    x1 = y1 ^ y2 ^ (y0 & y1) ^ (y0 & y3);
    x2 = y2 ^ y3 ^ (y1 & y2) ^ (y0 & y3);
    x3 = y3 ^ (y0 & y2) ^ (y1 & y2);
    
    y0 = x0; y1 = x1; y2 = x2; y3 = x3;
}</code></pre>
        </div>

        <div id="permutations" class="section">
            <h2>5. Initial and Final Permutations</h2>
            
            <h3 id="permutation-math">5.1 Mathematical Formulation</h3>
            <p>In bitslice implementation, permutations are handled differently. Instead of permuting individual bits within a single block, we need to permute the bit positions across multiple blocks processed in parallel.</p>
            
            <div class="math">
                <p><strong>IP: {0,1}¹²⁸ → {0,1}¹²⁸</strong></p>
                <p><strong>FP: {0,1}¹²⁸ → {0,1}¹²⁸</strong></p>
                <p>where IP and FP are bijections that rearrange bit positions.</p>
            </div>
            
            <h3 id="bitslice-permutations">5.2 Bitslice Permutation Implementation</h3>
            <p>In bitslice mode, we process multiple blocks in parallel. Each 32-bit word contains the same bit position from 32 different blocks. Permutations must be handled at the word level:</p>
            
            <div class="example">
                <strong>Bitslice Permutation Concept:</strong><br>
                Instead of permuting bits within a single block, we permute the word order and bit positions to maintain the correct mapping across all parallel blocks.
            </div>
            
            <h4>Bitslice Initial Permutation</h4>
            <p>The Initial Permutation (IP) rearranges bits according to the IP table. In bitslice mode, we need to implement this as word-level operations:</p>
            
            <pre><code>// IP and FP tables
static const uint8_t IP[128] = {
    0, 32, 64, 96, 1, 33, 65, 97, 2, 34, 66, 98, 3, 35, 67, 99,
    4, 36, 68, 100, 5, 37, 69, 101, 6, 38, 70, 102, 7, 39, 71, 103,
    8, 40, 72, 104, 9, 41, 73, 105, 10, 42, 74, 106, 11, 43, 75, 107,
    12, 44, 76, 108, 13, 45, 77, 109, 14, 46, 78, 110, 15, 47, 79, 111,
    16, 48, 80, 112, 17, 49, 81, 113, 18, 50, 82, 114, 19, 51, 83, 115,
    20, 52, 84, 116, 21, 53, 85, 117, 22, 54, 86, 118, 23, 55, 87, 119,
    24, 56, 88, 120, 25, 57, 89, 121, 26, 58, 90, 122, 27, 59, 91, 123,
    28, 60, 92, 124, 29, 61, 93, 125, 30, 62, 94, 126, 31, 63, 95, 127
};

static const uint8_t FP[128] = {
    0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
    64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
    1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61,
    65, 69, 73, 77, 81, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125,
    2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62,
    66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, 126,
    3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63,
    67, 71, 75, 79, 83, 87, 91, 95, 99, 103, 107, 111, 115, 119, 123, 127
};

// Bitslice Initial Permutation
void bitslice_initial_permutation(uint32_t state[4]) {
    // IP table: bit i goes to position IP[i]
    // In bitslice mode, we need to rearrange bits across words
    
    uint32_t new_state[4] = {0, 0, 0, 0};
    
    // For each bit position in the original state
    for (int bit_pos = 0; bit_pos < 128; bit_pos++) {
        int word_idx = bit_pos / 32;
        int bit_idx = bit_pos % 32;
        
        // Get the new position from IP table
        int new_pos = IP[bit_pos];
        int new_word_idx = new_pos / 32;
        int new_bit_idx = new_pos % 32;
        
        // Extract the bit from original position
        uint32_t bit_value = (state[word_idx] >> bit_idx) & 1;
        
        // Place it in the new position
        new_state[new_word_idx] |= (bit_value << new_bit_idx);
    }
    
    // Copy back to state
    for (int i = 0; i < 4; i++) {
        state[i] = new_state[i];
    }
}</code></pre>
            
            <h4>Bitslice Final Permutation</h4>
            <p>The Final Permutation (FP) rearranges bits according to the FP table. This is the inverse of IP:</p>
            
            <pre><code>// Bitslice Final Permutation
void bitslice_final_permutation(uint32_t state[4]) {
    // FP table: bit i goes to position FP[i]
    // This is the inverse of IP
    
    uint32_t new_state[4] = {0, 0, 0, 0};
    
    // For each bit position in the original state
    for (int bit_pos = 0; bit_pos < 128; bit_pos++) {
        int word_idx = bit_pos / 32;
        int bit_idx = bit_pos % 32;
        
        // Get the new position from FP table
        int new_pos = FP[bit_pos];
        int new_word_idx = new_pos / 32;
        int new_bit_idx = new_pos % 32;
        
        // Extract the bit from original position
        uint32_t bit_value = (state[word_idx] >> bit_idx) & 1;
        
        // Place it in the new position
        new_state[new_word_idx] |= (bit_value << new_bit_idx);
    }
    
    // Copy back to state
    for (int i = 0; i < 4; i++) {
        state[i] = new_state[i];
    }
}</code></pre>
            
            <h4>Inverse Bitslice Permutations</h4>
            <p>For decryption, we need the inverse permutations. The inverse of IP is FP, and the inverse of FP is IP:</p>
            
            <pre><code>// Inverse Bitslice Initial Permutation (for decryption)
void bitslice_inverse_initial_permutation(uint32_t state[4]) {
    // This is the inverse of IP, which is FP
    bitslice_final_permutation(state);
}

// Inverse Bitslice Final Permutation (for decryption)
void bitslice_inverse_final_permutation(uint32_t state[4]) {
    // This is the inverse of FP, which is IP
    bitslice_initial_permutation(state);
}</code></pre>
            
            <h3 id="permutation-notes">5.3 Permutation Notes for Bitslice</h3>
            <p>Important considerations for bitslice permutation implementation:</p>
            
            <div class="info">
                <strong>Important Bitslice Considerations:</strong>
                <ul>
                    <li><strong>Bit-Level Operations:</strong> Permutations operate on individual bits, not words</li>
                    <li><strong>Cross-Word Movement:</strong> Bits can move between different 32-bit words</li>
                    <li><strong>Performance Impact:</strong> Permutations can be expensive in bitslice mode due to bit-level operations</li>
                    <li><strong>Correct Implementation:</strong> Must use the actual IP and FP tables, not identity operations</li>
                </ul>
            </div>
            
            <div class="warning">
                <strong>Important:</strong> The previous implementation showing identity operations was incorrect. The actual Serpent IP and FP permutations perform significant bit rearrangements that are essential for the cipher's security. While some implementations may omit these for performance reasons, doing so changes the cipher and should be clearly documented.
            </div>
            
            <h4>Permutation Analysis</h4>
            <p>Looking at the IP and FP tables:</p>
            
            <div class="example">
                <strong>IP Table Pattern:</strong><br>
                • Bit 0 stays at position 0<br>
                • Bit 1 moves to position 32<br>
                • Bit 2 moves to position 64<br>
                • Bit 3 moves to position 96<br>
                • Bit 4 moves to position 1<br>
                • And so on...<br><br>
                
                <strong>FP Table Pattern:</strong><br>
                • Bit 0 stays at position 0<br>
                • Bit 1 moves to position 4<br>
                • Bit 2 moves to position 8<br>
                • Bit 3 moves to position 12<br>
                • Bit 4 moves to position 16<br>
                • And so on...
            </div>
            
            <p>These permutations provide important diffusion properties that contribute to Serpent's security. The IP spreads bits across different words, while the FP concentrates them in a different pattern.</p>
        </div>

        <div id="linear-transformation" class="section">
            <h2>6. Linear Transformation</h2>
            
            <h3 id="lt-math">6.1 Bitslice Mathematical Formulation</h3>
            <p>In bitslice mode, the linear transformation LT: {0,1}¹²⁸ → {0,1}¹²⁸ operates on word-level representations where each 32-bit word contains parallel bits from multiple blocks:</p>
            
            <div class="math">
                <p><strong>LT(X₀, X₁, X₂, X₃) = (X₀', X₁', X₂', X₃')</strong></p>
            </div>
            
            <p>where Xᵢ represents a 32-bit word containing bit position i from 32 parallel blocks, and each Xᵢ' is computed through word-level rotations and XORs:</p>
            
            <div class="math">
                <p><strong>Step 1:</strong> T₀ = ROTL(X₀, 13), T₁ = ROTL(X₁, 1), T₂ = ROTL(X₂, 3), T₃ = ROTL(X₃, 7)</p>
                <p><strong>Step 2:</strong> X₀' = T₀ ⊕ X₁ ⊕ X₃, X₁' = X₁ ⊕ X₀ ⊕ X₂, X₂' = T₂ ⊕ X₃ ⊕ X₀, X₃' = X₃ ⊕ X₂ ⊕ T₀</p>
                <p><strong>Step 3:</strong> T₀ = ROTL(X₀', 5), T₁ = ROTL(X₁', 1), T₂ = ROTL(X₂', 3), T₃ = ROTL(X₃', 7)</p>
                <p><strong>Step 4:</strong> X₀'' = T₀ ⊕ X₁' ⊕ X₃', X₁'' = X₁' ⊕ X₀' ⊕ X₂', X₂'' = T₂ ⊕ X₃' ⊕ X₀', X₃'' = X₃' ⊕ X₂' ⊕ T₀</p>
                <p><strong>Step 5:</strong> X₀''' = ROTL(X₀'', 13), X₁''' = ROTL(X₁'', 1), X₂''' = ROTL(X₂'', 3), X₃''' = ROTL(X₃'', 7)</p>
            </div>
            
            <h3 id="lt-design">6.2 Bitslice Linear Transformation Design</h3>
            <p>The bitslice linear transformation (LT) is optimized for parallel processing, where each 32-bit word operation affects multiple blocks simultaneously. It's designed to provide excellent diffusion across all parallel blocks.</p>
            
            <div class="info">
                <strong>Bitslice LT Properties:</strong>
                <ul>
                    <li><strong>Parallel Diffusion:</strong> Each output bit depends on many input bits across all parallel blocks</li>
                    <li><strong>Word-Level Efficiency:</strong> Operations work on 32-bit words rather than individual bits</li>
                    <li><strong>High Branch Number:</strong> Maintains high branch number for good diffusion properties</li>
                    <li><strong>Parallel XORs:</strong> XOR operations mix bits across all 32 parallel blocks simultaneously</li>
                    <li><strong>Efficient Rotations:</strong> ROTL/ROTR operations are very efficient on modern processors</li>
                    <li><strong>Invertibility:</strong> LT is mathematically invertible for decryption</li>
                </ul>
            </div>
            
            <h3 id="lt-algorithm">6.3 Bitslice LT Algorithm</h3>
            <p>In bitslice mode, the linear transformation operates on word-level rotations and XORs, where each word contains the same bit position from multiple blocks:</p>
            
            <pre><code>// Bitslice Linear Transformation
void bitslice_linear_transform(uint32_t state[4]) {
    uint32_t X0 = state[0], X1 = state[1], X2 = state[2], X3 = state[3];
    uint32_t t0, t1, t2, t3;
    
    // Step 1: Initial rotations and XORs
    t0 = ROTL(X0, 13);
    t1 = ROTL(X1, 1);
    t2 = ROTL(X2, 3);
    t3 = ROTL(X3, 7);
    
    // Step 2: First round of mixing
    X0 = t0 ^ X1 ^ X3;
    X1 = X1 ^ X0 ^ X2;
    X2 = t2 ^ X3 ^ X0;
    X3 = X3 ^ X2 ^ t0;
    
    // Step 3: Additional rotations
    t0 = ROTL(X0, 5);
    t1 = ROTL(X1, 1);
    t2 = ROTL(X2, 3);
    t3 = ROTL(X3, 7);
    
    // Step 4: Second round of mixing
    X0 = t0 ^ X1 ^ X3;
    X1 = X1 ^ X0 ^ X2;
    X2 = t2 ^ X3 ^ X0;
    X3 = X3 ^ X2 ^ t0;
    
    // Step 5: Final rotations
    X0 = ROTL(X0, 13);
    X1 = ROTL(X1, 1);
    X2 = ROTL(X2, 3);
    X3 = ROTL(X3, 7);
    
    // Update state
    state[0] = X0; state[1] = X1; state[2] = X2; state[3] = X3;
}

// Helper function for left rotation
uint32_t ROTL(uint32_t x, int n) {
    return (x << n) | (x >> (32 - n));
}</code></pre>
            
            <h3 id="inverse-lt">6.4 Inverse Bitslice Linear Transformation</h3>
            <p>For decryption, we need the inverse linear transformation that reverses the bitslice operations:</p>
            
            <pre><code>// Inverse Bitslice Linear Transformation
void bitslice_inverse_linear_transform(uint32_t state[4]) {
    uint32_t X0 = state[0], X1 = state[1], X2 = state[2], X3 = state[3];
    uint32_t t0, t1, t2, t3;
    
    // Inverse of final rotations
    X0 = ROTR(X0, 13);
    X1 = ROTR(X1, 1);
    X2 = ROTR(X2, 3);
    X3 = ROTR(X3, 7);
    
    // Inverse of second round of mixing
    t0 = X0 ^ X1 ^ X3;
    X1 = X1 ^ X0 ^ X2;
    t2 = X2 ^ X3 ^ X0;
    X3 = X3 ^ X2 ^ t0;
    
    // Inverse of additional rotations
    X0 = ROTR(t0, 5);
    X1 = ROTR(X1, 1);
    X2 = ROTR(t2, 3);
    X3 = ROTR(X3, 7);
    
    // Inverse of first round of mixing
    t0 = X0 ^ X1 ^ X3;
    X1 = X1 ^ X0 ^ X2;
    t2 = X2 ^ X3 ^ X0;
    X3 = X3 ^ X2 ^ t0;
    
    // Inverse of initial rotations
    X0 = ROTR(t0, 13);
    X1 = ROTR(X1, 1);
    X2 = ROTR(t2, 3);
    X3 = ROTR(X3, 7);
    
    // Update state
    state[0] = X0; state[1] = X1; state[2] = X2; state[3] = X3;
}

// Helper function for right rotation
uint32_t ROTR(uint32_t x, int n) {
    return (x >> n) | (x << (32 - n));
}</code></pre>
            
            <h3 id="lt-bitslice-notes">6.5 Bitslice LT Notes</h3>
            <div class="info">
                <strong>Bitslice Linear Transformation Properties:</strong>
                <ul>
                    <li><strong>Word-Level Operations:</strong> All operations work on 32-bit words containing parallel bits</li>
                    <li><strong>Efficient Rotations:</strong> ROTL/ROTR operations are very efficient in bitslice mode</li>
                    <li><strong>Parallel XORs:</strong> XOR operations mix bits across all parallel blocks simultaneously</li>
                    <li><strong>Diffusion:</strong> Each output bit depends on many input bits across all parallel blocks</li>
                    <li><strong>Invertibility:</strong> The transformation is mathematically invertible for decryption</li>
                </ul>
            </div>
            
            <div class="example">
                <strong>Bitslice LT Advantage:</strong><br>
                In bitslice mode, the linear transformation can process 32 blocks in parallel, making it much more efficient than traditional bit-by-bit implementations.
            </div>
        </div>

        <div id="encryption" class="section">
            <h2>7. Bitslice Encryption Algorithm</h2>
            
            <h3 id="encryption-math">7.1 Bitslice Mathematical Formulation</h3>
            <p>In bitslice mode, encryption processes multiple blocks in parallel. Each 32-bit word contains the same bit position from 32 different blocks. The encryption function E: {0,1}¹²⁸ × {0,1}²⁵⁶ → {0,1}¹²⁸ maps plaintext P and key K to ciphertext C.</p>
            
            <h4>Bitslice Initial Permutation</h4>
            <p>The bitslice initial permutation IP: {0,1}¹²⁸ → {0,1}¹²⁸ operates on word-level representations:</p>
            
            <div class="math">
                <p><strong>X₀ = IP(P)</strong></p>
            </div>
            
            <h4>Bitslice Round Function</h4>
            <p>Each round r applies the bitslice round function F: {0,1}¹²⁸ × {0,1}¹²⁸ × ℕ → {0,1}¹²⁸:</p>
            
            <div class="math">
                <p><strong>F(X, K, r) = LT(S₍₍ᵣ₋₁₎ ₘₒₙ ₈₎(X ⊕ K))</strong></p>
                <p>where Sⱼ is the bitslice implementation of S-box j, and LT is the bitslice linear transformation.</p>
            </div>
            
            <h4>Complete Bitslice Encryption</h4>
            <p>The complete bitslice encryption process is:</p>
            
            <div class="math">
                <p><strong>X₀ = IP(P) ⊕ K⁽⁰⁾</strong></p>
                <p><strong>Xᵣ = F(Xᵣ₋₁, K⁽ʳ⁾, r)</strong> for r = 1, 2, ..., 31</p>
                <p><strong>X₃₂ = S₇(X₃₁ ⊕ K⁽³¹⁾) ⊕ K⁽³²⁾</strong></p>
                <p><strong>C = FP(X₃₂)</strong></p>
            </div>
            
            <h3 id="encryption-overview">7.2 Bitslice Encryption Overview</h3>
            <p>Bitslice Serpent encryption processes 32 blocks in parallel, with each 32-bit word containing parallel bits from multiple blocks. The algorithm consists of 32 rounds plus initial and final transformations.</p>
            
            <div class="example">
                <strong>Bitslice Encryption Process:</strong>
                <ol>
                    <li>Apply Bitslice Initial Permutation (IP)</li>
                    <li>Add Round Key 0 (word-level XOR)</li>
                    <li>32 rounds of bitslice encryption</li>
                    <li>Add Round Key 32 (word-level XOR)</li>
                    <li>Apply Bitslice Final Permutation (FP)</li>
                </ol>
            </div>
            
            <h3 id="round-function">7.3 Bitslice Round Function</h3>
            <p>Each bitslice round operates on word-level representations:</p>
            
            <pre><code>void bitslice_serpent_round(uint32_t state[4], uint32_t round_key[4], int round_num) {
    // Step 1: Add round key (word-level XOR)
    for (int i = 0; i < 4; i++) {
        state[i] ^= round_key[i];
    }
    
    // Step 2: Apply bitslice S-box substitution
    int sbox_num = (round_num - 1) % 8;  // S-box 0 to 7, cycling
    
    // Apply bitslice S-box directly to words
    switch (sbox_num) {
        case 0: sbox0_bitslice(state[0], state[1], state[2], state[3]); break;
        case 1: sbox1_bitslice(state[0], state[1], state[2], state[3]); break;
        case 2: sbox2_bitslice(state[0], state[1], state[2], state[3]); break;
        case 3: sbox3_bitslice(state[0], state[1], state[2], state[3]); break;
        case 4: sbox4_bitslice(state[0], state[1], state[2], state[3]); break;
        case 5: sbox5_bitslice(state[0], state[1], state[2], state[3]); break;
        case 6: sbox6_bitslice(state[0], state[1], state[2], state[3]); break;
        case 7: sbox7_bitslice(state[0], state[1], state[2], state[3]); break;
    }
    
    // Step 3: Apply bitslice linear transformation (except last round)
    if (round_num < 32) {
        bitslice_linear_transform(state);
    }
}</code></pre>
            
            <h3 id="complete-encryption">7.4 Complete Bitslice Encryption Process</h3>
            <pre><code>void bitslice_serpent_encrypt(const uint8_t* plaintext, const uint8_t* key, uint8_t* ciphertext) {
    uint32_t state[4];
    uint32_t round_keys[33][4];
    
    // Generate round keys
    SerpentKeySchedule::generate_round_keys(key, round_keys);
    
    // Convert plaintext to bitslice state
    for (int i = 0; i < 4; i++) {
        state[i] = (plaintext[4*i] << 24) | (plaintext[4*i+1] << 16) | 
                   (plaintext[4*i+2] << 8) | plaintext[4*i+3];
    }
    
    // Apply bitslice initial permutation
    bitslice_initial_permutation(state);
    
    // Add round key 0
    for (int i = 0; i < 4; i++) {
        state[i] ^= round_keys[0][i];
    }
    
    // 32 rounds
    for (int round = 1; round <= 32; round++) {
        bitslice_serpent_round(state, round_keys[round], round);
    }
    
    // Apply bitslice final permutation
    bitslice_final_permutation(state);
    
    // Convert bitslice state to ciphertext
    for (int i = 0; i < 4; i++) {
        ciphertext[4*i] = (state[i] >> 24) & 0xFF;
        ciphertext[4*i+1] = (state[i] >> 16) & 0xFF;
        ciphertext[4*i+2] = (state[i] >> 8) & 0xFF;
        ciphertext[4*i+3] = state[i] & 0xFF;
    }
}</code></pre>
        </div>

        <div id="decryption" class="section">
            <h2>8. Bitslice Decryption Algorithm</h2>
            
            <h3 id="decryption-math">8.1 Bitslice Mathematical Formulation</h3>
            <p>In bitslice mode, decryption is the inverse function D: {0,1}¹²⁸ × {0,1}²⁵⁶ → {0,1}¹²⁸ that processes multiple blocks in parallel.</p>
            
            <h4>Bitslice Inverse Operations</h4>
            <p>Bitslice decryption uses the inverse operations:</p>
            
            <div class="math">
                <p><strong>F⁻¹(X, K, r) = S₍₍ᵣ₋₁₎ ₘₒₙ ₈₎⁻¹(LT⁻¹(X)) ⊕ K</strong></p>
            </div>
            
            <h4>Complete Bitslice Decryption</h4>
            <div class="math">
                <p><strong>X₃₂ = FP⁻¹(C) ⊕ K⁽³²⁾</strong></p>
                <p><strong>Xᵣ₋₁ = F⁻¹(Xᵣ, K⁽ʳ⁾, r)</strong> for r = 32, 31, ..., 2</p>
                <p><strong>P = IP⁻¹(X₀ ⊕ K⁽⁰⁾)</strong></p>
            </div>
            
            <h3 id="decryption-overview">8.2 Bitslice Decryption Overview</h3>
            <p>Bitslice decryption is the inverse of bitslice encryption, performed in reverse order with inverse operations on word-level representations.</p>
            
            <div class="example">
                <strong>Bitslice Decryption Process:</strong>
                <ol>
                    <li>Apply Inverse Bitslice Final Permutation (FP⁻¹)</li>
                    <li>Add Round Key 32 (word-level XOR)</li>
                    <li>32 rounds of bitslice decryption (in reverse order)</li>
                    <li>Add Round Key 0 (word-level XOR)</li>
                    <li>Apply Inverse Bitslice Initial Permutation (IP⁻¹)</li>
                </ol>
            </div>
            
            <h3 id="inverse-round">8.3 Bitslice Inverse Round Function</h3>
            <pre><code>void bitslice_serpent_inverse_round(uint32_t state[4], uint32_t round_key[4], int round_num) {
    // Step 1: Apply inverse bitslice linear transformation (except first round)
    if (round_num > 1) {
        bitslice_inverse_linear_transform(state);
    }
    
    // Step 2: Apply inverse bitslice S-box substitution
    int sbox_num = (round_num - 1) % 8;
    
    // Apply inverse bitslice S-box directly to words
    switch (sbox_num) {
        case 0: sbox0_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 1: sbox1_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 2: sbox2_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 3: sbox3_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 4: sbox4_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 5: sbox5_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 6: sbox6_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
        case 7: sbox7_inverse_bitslice(state[0], state[1], state[2], state[3]); break;
    }
    
    // Step 3: Add round key (word-level XOR)
    for (int i = 0; i < 4; i++) {
        state[i] ^= round_key[i];
    }
}</code></pre>
            
            <h3 id="complete-decryption">8.4 Complete Decryption Process</h3>
            <pre><code>void serpent_decrypt(const uint8_t* ciphertext, const uint8_t* key, uint8_t* plaintext) {
    uint32_t state[4];
    uint32_t round_keys[33][4];
    
    // Generate round keys
    SerpentKeySchedule::generate_round_keys(key, round_keys);
    
    // Convert ciphertext to state
    for (int i = 0; i < 4; i++) {
        state[i] = (ciphertext[4*i] << 24) | (ciphertext[4*i+1] << 16) | 
                   (ciphertext[4*i+2] << 8) | ciphertext[4*i+3];
    }
    
    // Apply inverse final permutation
    apply_final_permutation(state);
    
    // Add round key 32
    for (int i = 0; i < 4; i++) {
        state[i] ^= round_keys[32][i];
    }
    
    // 32 rounds in reverse order
    for (int round = 32; round >= 1; round--) {
        serpent_inverse_round(state, round_keys[round-1], round);
    }
    
    // Apply inverse initial permutation
    apply_initial_permutation(state);
    
    // Convert state to plaintext
    for (int i = 0; i < 4; i++) {
        plaintext[4*i] = (state[i] >> 24) & 0xFF;
        plaintext[4*i+1] = (state[i] >> 16) & 0xFF;
        plaintext[4*i+2] = (state[i] >> 8) & 0xFF;
        plaintext[4*i+3] = state[i] & 0xFF;
    }
}</code></pre>
        </div>

        <div id="endianness" class="section">
            <h2>9. Endianness Considerations</h2>
            
            <h3 id="endianness-overview">9.1 Endianness Overview</h3>
            <p>Endianness refers to the byte order in which multi-byte data types are stored in memory. This is crucial for correct implementation across different architectures.</p>
            
            <div class="info">
                <strong>Endianness Types:</strong>
                <ul>
                    <li><strong>Little-endian:</strong> Least significant byte first (e.g., Intel x86, ARM)</li>
                    <li><strong>Big-endian:</strong> Most significant byte first (e.g., Motorola 68000, some ARM configurations)</li>
                    <li><strong>Bi-endian:</strong> Can be configured for either (e.g., ARM, PowerPC)</li>
                </ul>
            </div>
            
            <h3 id="serpent-endianness">9.2 Serpent Endianness Specification</h3>
            <p>The Serpent specification defines the cipher to operate in <strong>little-endian</strong> byte order. This means:</p>
            
            <div class="example">
                <strong>Little-Endian Representation:</strong><br>
                A 32-bit value 0x12345678 is stored as: 78 56 34 12
            </div>
            
            <h4>Bit Ordering</h4>
            <p>In Serpent, bits are numbered from 0 (least significant) to 127 (most significant):</p>
            
            <pre><code>// Bit numbering in a 128-bit block
// Word 0: bits 0-31   (least significant bits)
// Word 1: bits 32-63
// Word 2: bits 64-95
// Word 3: bits 96-127 (most significant bits)

// Within each 32-bit word:
// Bit 0: least significant bit
// Bit 31: most significant bit</code></pre>
            
            <h3 id="endianness-handling">9.3 Endianness Handling in Implementation</h3>
            <p>When implementing Serpent, you need to handle endianness conversion:</p>
            
            <pre><code>// Endianness detection and conversion
#include &lt;cstdint&gt;

// Check if system is little-endian
bool is_little_endian() {
    uint16_t test = 0x0001;
    return (*((uint8_t*)&test) == 0x01);
}

// Convert between host and little-endian
uint32_t host_to_le(uint32_t value) {
    if (is_little_endian()) {
        return value;  // No conversion needed
    } else {
        // Swap bytes for big-endian systems
        return ((value & 0xFF) << 24) |
               (((value >> 8) & 0xFF) << 16) |
               (((value >> 16) & 0xFF) << 8) |
               ((value >> 24) & 0xFF);
    }
}

uint32_t le_to_host(uint32_t value) {
    return host_to_le(value);  // Same operation
}</code></pre>
            
            <h4>Byte Order Conversion Functions</h4>
            <pre><code>// Convert 128-bit block to/from little-endian
void block_to_le(uint32_t state[4]) {
    for (int i = 0; i < 4; i++) {
        state[i] = host_to_le(state[i]);
    }
}

void block_from_le(uint32_t state[4]) {
    for (int i = 0; i < 4; i++) {
        state[i] = le_to_host(state[i]);
    }
}</code></pre>
            
            <h3 id="implementation-considerations">9.4 Implementation Considerations</h3>
            <div class="warning">
                <strong>Important Endianness Notes:</strong>
                <ul>
                    <li><strong>Test Vectors:</strong> Official Serpent test vectors assume little-endian byte order</li>
                    <li><strong>Cross-Platform:</strong> Always handle endianness for portable code</li>
                    <li><strong>Performance:</strong> Little-endian systems have no conversion overhead</li>
                    <li><strong>Debugging:</strong> Endianness issues can cause subtle bugs</li>
                </ul>
            </div>
            
            <h4>Updated Encryption Function with Endianness</h4>
            <pre><code>void serpent_encrypt_with_endianness(const uint8_t* plaintext, const uint8_t* key, uint8_t* ciphertext) {
    uint32_t state[4];
    uint32_t round_keys[33][4];
    
    // Generate round keys
    SerpentKeySchedule::generate_round_keys(key, round_keys);
    
    // Convert plaintext to state (assuming input is in little-endian)
    for (int i = 0; i < 4; i++) {
        state[i] = (plaintext[4*i] << 24) | (plaintext[4*i+1] << 16) | 
                   (plaintext[4*i+2] << 8) | plaintext[4*i+3];
    }
    
    // Convert to little-endian for Serpent processing
    block_to_le(state);
    
    // Apply initial permutation
    apply_initial_permutation(state);
    
    // Add round key 0
    for (int i = 0; i < 4; i++) {
        state[i] ^= round_keys[0][i];
    }
    
    // 32 rounds
    for (int round = 1; round <= 32; round++) {
        serpent_round(state, round_keys[round], round);
    }
    
    // Apply final permutation
    apply_final_permutation(state);
    
    // Convert from little-endian for output
    block_from_le(state);
    
    // Convert state to ciphertext
    for (int i = 0; i < 4; i++) {
        ciphertext[4*i] = (state[i] >> 24) & 0xFF;
        ciphertext[4*i+1] = (state[i] >> 16) & 0xFF;
        ciphertext[4*i+2] = (state[i] >> 8) & 0xFF;
        ciphertext[4*i+3] = state[i] & 0xFF;
    }
}</code></pre>
            
            <h3 id="testing-endianness">9.5 Testing with Different Endianness</h3>
            <pre><code>bool test_endianness_handling() {
    // Test vector in little-endian format
    uint8_t key[32] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
    };
    
    uint8_t plaintext[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    
    uint8_t expected_ciphertext[16] = {
        0x26, 0x4D, 0x3C, 0xE3, 0xDB, 0x95, 0x2D, 0x65,
        0x3D, 0xF2, 0x98, 0xFA, 0x47, 0xBC, 0x8B, 0x37
    };
    
    uint8_t ciphertext[16];
    
    // Test with endianness handling
    serpent_encrypt_with_endianness(plaintext, key, ciphertext);
    
    // Verify result
    if (memcmp(ciphertext, expected_ciphertext, 16) != 0) {
        std::cout << "Endianness test failed!" << std::endl;
        return false;
    }
    
    std::cout << "Endianness test passed!" << std::endl;
    return true;
}</code></pre>
        </div>

        <div id="implementation" class="section">
            <h2>10. Complete Bitslice Implementation</h2>
            
            <h3 id="c-implementation">10.1 C++ Bitslice Implementation</h3>
            <p>Here's a complete C++ implementation of the bitslice Serpent cipher optimized for parallel processing:</p>
            
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdint&gt;
#include &lt;cstring&gt;

class BitsliceSerpent {
private:
    // Key schedule constants
    static const uint32_t PHI = 0x9E3779B9;
    
    // Helper functions
    static uint32_t ROTL(uint32_t x, int n) {
        return (x << n) | (x >> (32 - n));
    }
    
    static uint32_t ROTR(uint32_t x, int n) {
        return (x >> n) | (x << (32 - n));
    }
    
    // Bitslice S-Box implementations
    static void sbox0_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox1_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox2_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox3_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox4_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox5_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox6_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    static void sbox7_bitslice(uint32_t& x0, uint32_t& x1, uint32_t& x2, uint32_t& x3);
    
    // Bitslice inverse S-Box implementations
    static void sbox0_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox1_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox2_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox3_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox4_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox5_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox6_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    static void sbox7_inverse_bitslice(uint32_t& y0, uint32_t& y1, uint32_t& y2, uint32_t& y3);
    
    // Bitslice core functions
    static void bitslice_initial_permutation(uint32_t state[4]);
    static void bitslice_final_permutation(uint32_t state[4]);
    static void bitslice_inverse_initial_permutation(uint32_t state[4]);
    static void bitslice_inverse_final_permutation(uint32_t state[4]);
    static void bitslice_linear_transform(uint32_t state[4]);
    static void bitslice_inverse_linear_transform(uint32_t state[4]);
    static void bitslice_serpent_round(uint32_t state[4], uint32_t round_key[4], int round_num);
    static void bitslice_serpent_inverse_round(uint32_t state[4], uint32_t round_key[4], int round_num);
    static void generate_round_keys(const uint8_t* key, uint32_t round_keys[33][4]);
    
public:
    static void encrypt(const uint8_t* plaintext, const uint8_t* key, uint8_t* ciphertext);
    static void decrypt(const uint8_t* ciphertext, const uint8_t* key, uint8_t* plaintext);
    static bool test_implementation();
};

// Implementation of core functions...
// (Previous implementations would go here)</code></pre>
            
            <h3 id="testing">10.2 Bitslice Testing and Validation</h3>
            <pre><code>bool BitsliceSerpent::test_implementation() {
    // Test vectors for bitslice implementation
    uint8_t key[32] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
    };
    
    uint8_t plaintext[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    
    uint8_t expected_ciphertext[16] = {
        0x26, 0x4D, 0x3C, 0xE3, 0xDB, 0x95, 0x2D, 0x65,
        0x3D, 0xF2, 0x98, 0xFA, 0x47, 0xBC, 0x8B, 0x37
    };
    
    uint8_t ciphertext[16];
    uint8_t decrypted[16];
    
    // Test bitslice encryption
    encrypt(plaintext, key, ciphertext);
    
    // Verify encryption
    if (memcmp(ciphertext, expected_ciphertext, 16) != 0) {
        std::cout << "Bitslice encryption test failed!" << std::endl;
        return false;
    }
    
    // Test bitslice decryption
    decrypt(ciphertext, key, decrypted);
    
    // Verify decryption
    if (memcmp(decrypted, plaintext, 16) != 0) {
        std::cout << "Bitslice decryption test failed!" << std::endl;
        return false;
    }
    
    std::cout << "All bitslice tests passed!" << std::endl;
    return true;
}</code></pre>
            
            <h3 id="examples">10.3 Complete Bitslice Examples</h3>
            <div class="example">
                <strong>Example: Bitslice Encrypting and Decrypting a Message</strong>
                
                <pre><code>int main() {
    // Test the bitslice implementation
    if (!BitsliceSerpent::test_implementation()) {
        std::cout << "Bitslice implementation test failed!" << std::endl;
        return 1;
    }
    
    // Example usage with bitslice processing
    uint8_t key[32] = {0};  // All zeros for simplicity
    uint8_t message[16] = "Hello, Serpent!";
    uint8_t encrypted[16];
    uint8_t decrypted[16];
    
    std::cout << "Original message: " << message << std::endl;
    
    // Bitslice encrypt
    BitsliceSerpent::encrypt(message, key, encrypted);
    std::cout << "Bitslice encrypted: ";
    for (int i = 0; i < 16; i++) {
        printf("%02X ", encrypted[i]);
    }
    std::cout << std::endl;
    
    // Bitslice decrypt
    BitsliceSerpent::decrypt(encrypted, key, decrypted);
    std::cout << "Bitslice decrypted: " << decrypted << std::endl;
    
    return 0;
}</code></pre>
            </div>
            
            <div class="warning">
                <strong>Important Notes:</strong>
                <ul>
                    <li>This is an educational implementation. For production use, use well-tested libraries.</li>
                    <li>The implementation should be constant-time to prevent timing attacks.</li>
                    <li>Always use secure random number generators for keys.</li>
                    <li>Consider using authenticated encryption modes for real applications.</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Conclusion</h2>
            <p>This guide has provided a comprehensive introduction to the Serpent block cipher, including its bitslice implementation. We've covered:</p>
            
            <ul>
                <li><strong>Mathematical foundations</strong> of Boolean algebra and bit operations</li>
                <li><strong>Key schedule</strong> generation and round key derivation</li>
                <li><strong>S-boxes and their inverses</strong> with both lookup tables and Boolean functions</li>
                <li><strong>Initial and final permutations</strong> and their inverses</li>
                <li><strong>Linear transformation</strong> and its inverse for diffusion</li>
                <li><strong>Complete encryption and decryption</strong> algorithms</li>
                <li><strong>Full C++ implementation</strong> with testing framework</li>
            </ul>
            
            <p>The bitslice implementation offers significant performance advantages for parallel processing while maintaining the security properties of the original Serpent design. Understanding these concepts provides a solid foundation for studying other block ciphers and cryptographic implementations.</p>
        </div>
    </div>
</body>
</html> 