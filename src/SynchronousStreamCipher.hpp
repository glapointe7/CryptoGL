
#ifndef SYNCHRONOUSSTREAMCIPHER_HPP
#define SYNCHRONOUSSTREAMCIPHER_HPP

#include "StreamCipher.hpp"

#include "BigEndian.hpp"

template <class KeystreamType>
class SynchronousStreamCipher : public StreamCipher<KeystreamType>
{
public:
   virtual const BytesVector encode(const BytesVector &message) final
   {
      const uint64_t output_size = message.size();
      BytesVector output;
      output.reserve(output_size);

      const uint8_t type_size = sizeof(KeystreamType);
      for(uint64_t i = 0; i < output_size; i += keystream_size)
      {
         const UInt32Vector keystream = generateKeystream();
         for(uint16_t j = 0; j < keystream_size; j += type_size)
         {
            const BytesVector key_bytes = BigEndian<KeystreamType>::toBytesVector(keystream[j / type_size]);
            for(uint8_t k = 0; k < type_size; ++k)
            {
               const uint64_t current_len = i+j+k;
               if(current_len == output_size)
               {
                  return output;
               }
               output.push_back(message[current_len] ^ key_bytes[k]);
            }
         }
      }

      return output;
   }
   
protected:   
   using KeystreamVectorType = typename StreamCipher<KeystreamType>::KeystreamVectorType;
   
   explicit SynchronousStreamCipher(const uint64_t &keystream_size) 
      : keystream_size(keystream_size) {}
      
   virtual ~SynchronousStreamCipher() {}
   
   virtual KeystreamVectorType generateKeystream() = 0;
   
   /* Set the key and check if the key has a correct length. */
   virtual void setKey(const BytesVector &) = 0;
   
   virtual void keySetup() = 0;

   /* Number of integers generated by one call to generateKeystream. */
   const uint64_t keystream_size;
};

#endif